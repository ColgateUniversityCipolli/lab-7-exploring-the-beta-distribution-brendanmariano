geom_line(aes(x=x, y=norm.pdf, color="Gaussian(0.2857, 0.0255)")) +  # plot guassian dist
geom_hline(yintercept=0)+                                            # plot x axis
theme_bw()+                                                          # change theme
xlab("x")+                                                           # label x axis
ylab("Density")+                                                     # label y axis
scale_color_manual("", values = c("orange", "grey"))+                 # change colors
theme(legend.position = "bottom")
values = tibble(mean = numeric(1), variance = numeric(1),
skewness = numeric(1), kurtosis = numeric(1)) |>
mutate(mean = alpha/(alpha + beta)) |>
mutate(variance = (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))) |>
mutate(skewness = 2*(beta-alpha)*(alpha+beta+1)^(1/2)/((alpha+beta+2)*(alpha*beta)^(1/2))) |>
mutate(kurtosis = 6*((alpha-beta)^2*(alpha+beta+1)-alpha*beta*(alpha+beta+2))
/(alpha*beta*(alpha+beta+2)*(alpha+beta+3)))
return (list(plot = plot, values = values))
}
alpha.vals = c(2,5,5,.5)
beta.vals = c(5,5,2,.5)
total.data = tibble(mean = numeric(0), variance = numeric(0),
skewness = numeric(0), kurtosis = numeric(0))
all.plots = list()
for(i in 1:4)
{
return.val = calculate_distribution(alpha.vals[i], beta.vals[i])
total.data = bind_rows(total.data, return.val$values)
all.plots[[i]] <- return.val$plot
}
print(all.plots[[1]])
print(all.plots[[2]])
print(all.plots[[3]])
print(all.plots[[4]])
#Step 2:
beta.moment <- function(alpha, beta, k, centered)
{
mean.funct = function(x) x^1*dbeta(x,alpha, beta)
mean.val = integrate(mean.funct,lower = 0,upper = 1)$value
print(mean.val)
if(k == 1)
{
mean.val
}
else if(k == 2)
{
variance.funct = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
variance.val = integrate(variance.funct, 0,1)
variance.val$value
}
else if(k == 3)
{
skewness.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
skewness.val.top = integrate(skewness.funct.top, 0,1)$value
skewness.funct.bott = function(x) (x-mean.val)^(k-1)*dbeta(x,alpha,beta)
skewness.val.bott = integrate(skewness.funct.bott, 0,1)$value
skewness.val = skewness.val.top/(skewness.val.bott^(3/2))
skewness.val
}
else if(k == 4)
{
kurt.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
kurt.val.top = integrate(kurt.funct.top, 0, 1)$value
kurt.funct.bott = function(x) (x-mean.val)^(k-2) *dbeta(x,alpha,beta)
kurt.val.bott = integrate(kurt.funct.bott, 0, 1)$value
kurt.val = kurt.val.top/((kurt.val.bott)^2) -3
kurt.val
}
}
population.data = tibble()
for(i in 1:4)
{
row = tibble() |>
summarize(type = "Population", alpha = alpha.vals[i], beta = beta.vals[i],
mean = beta.moment(alpha.vals[i], beta.vals[i],1,F),
variance = beta.moment(alpha.vals[i], beta.vals[i], 2, T),
skewness = beta.moment(alpha.vals[i], beta.vals[i], 3,T),
excess.kurtosis = beta.moment(alpha.vals[i], beta.vals[i], 4, T))
population.data = bind_rows(population.data, row)
}
view(population.data)
#Creates histograms
#################################################################################
#Making Data Summaries
#################################################################################
set.seed(7272)
sample.size = 500
plot.list = list()
summaries.list = list()
i = 1
#Should call calculate distribution
for(i in 1:4)
{
total.distrib = tibble(type = character(), alpha = numeric(), beta = numeric(), mean = numeric(), variance = numeric(),
skewness = numeric(), excess.kurtosis = numeric())
beta.sample = tibble(x = rbeta(n = sample.size, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Stores actual probability density function
population.fig = tibble(x = seq(0, 1, length.out = 1000)) |>
mutate(beta.pdf = dbeta(x, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Creates plots
plot.list[[i]] = ggplot() +
geom_histogram(data = beta.sample, aes(x = x, y = after_stat(density)), fill = "royalblue") +
geom_density(data = beta.sample, aes(x = x, y = after_stat(density), color = "Sample")) +
geom_line(data = population.fig, aes(x = x, y = beta.pdf, color = "Population"))
#Making data summary table
summary = beta.sample %>%
summarize(type = "Sample", mean = mean(x), variance = var(x),
skewness = skewness(x), excess.kurtosis = kurtosis(x),
alpha = alpha.vals[i], beta = beta.vals[i])
total.distrib = bind_rows(total.distrib, summary)
total.distrib = bind_rows(total.distrib, population.data |> slice(i))
summaries.list[[i]] = total.distrib
}
plot.list[[1]]
plot.list[[2]]
plot.list[[3]]
plot.list[[4]]
################################################################################
#Task Four
################################################################################
cum.summ.mean = cummean(pull(population.fig, beta.pdf)) |>
mutate(x = population.fig, x)
library(tidyverse)
library(cumstats)
calculate_distribution <- function(alpha, beta)
{
q1.fig.dat <- tibble(x = seq(-0.25, 1.25, length.out=1000)) |>   # generate a grid of points
mutate(beta.pdf = dbeta(x, alpha, beta),
norm.pdf = dnorm(x, mean = alpha/(alpha+beta),
sd = sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1)))))  # Gaussian distribution with same mean and variance
plot = ggplot(data= q1.fig.dat)+                                              # specify data
geom_line(aes(x=x, y=beta.pdf, color="Beta(2,5)")) +                 # plot beta dist
geom_line(aes(x=x, y=norm.pdf, color="Gaussian(0.2857, 0.0255)")) +  # plot guassian dist
geom_hline(yintercept=0)+                                            # plot x axis
theme_bw()+                                                          # change theme
xlab("x")+                                                           # label x axis
ylab("Density")+                                                     # label y axis
scale_color_manual("", values = c("orange", "grey"))+                 # change colors
theme(legend.position = "bottom")
values = tibble(mean = numeric(1), variance = numeric(1),
skewness = numeric(1), kurtosis = numeric(1)) |>
mutate(mean = alpha/(alpha + beta)) |>
mutate(variance = (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))) |>
mutate(skewness = 2*(beta-alpha)*(alpha+beta+1)^(1/2)/((alpha+beta+2)*(alpha*beta)^(1/2))) |>
mutate(kurtosis = 6*((alpha-beta)^2*(alpha+beta+1)-alpha*beta*(alpha+beta+2))
/(alpha*beta*(alpha+beta+2)*(alpha+beta+3)))
return (list(plot = plot, values = values))
}
alpha.vals = c(2,5,5,.5)
beta.vals = c(5,5,2,.5)
total.data = tibble(mean = numeric(0), variance = numeric(0),
skewness = numeric(0), kurtosis = numeric(0))
all.plots = list()
for(i in 1:4)
{
return.val = calculate_distribution(alpha.vals[i], beta.vals[i])
total.data = bind_rows(total.data, return.val$values)
all.plots[[i]] <- return.val$plot
}
print(all.plots[[1]])
print(all.plots[[2]])
print(all.plots[[3]])
print(all.plots[[4]])
#Step 2:
beta.moment <- function(alpha, beta, k, centered)
{
mean.funct = function(x) x^1*dbeta(x,alpha, beta)
mean.val = integrate(mean.funct,lower = 0,upper = 1)$value
print(mean.val)
if(k == 1)
{
mean.val
}
else if(k == 2)
{
variance.funct = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
variance.val = integrate(variance.funct, 0,1)
variance.val$value
}
else if(k == 3)
{
skewness.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
skewness.val.top = integrate(skewness.funct.top, 0,1)$value
skewness.funct.bott = function(x) (x-mean.val)^(k-1)*dbeta(x,alpha,beta)
skewness.val.bott = integrate(skewness.funct.bott, 0,1)$value
skewness.val = skewness.val.top/(skewness.val.bott^(3/2))
skewness.val
}
else if(k == 4)
{
kurt.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
kurt.val.top = integrate(kurt.funct.top, 0, 1)$value
kurt.funct.bott = function(x) (x-mean.val)^(k-2) *dbeta(x,alpha,beta)
kurt.val.bott = integrate(kurt.funct.bott, 0, 1)$value
kurt.val = kurt.val.top/((kurt.val.bott)^2) -3
kurt.val
}
}
population.data = tibble()
for(i in 1:4)
{
row = tibble() |>
summarize(type = "Population", alpha = alpha.vals[i], beta = beta.vals[i],
mean = beta.moment(alpha.vals[i], beta.vals[i],1,F),
variance = beta.moment(alpha.vals[i], beta.vals[i], 2, T),
skewness = beta.moment(alpha.vals[i], beta.vals[i], 3,T),
excess.kurtosis = beta.moment(alpha.vals[i], beta.vals[i], 4, T))
population.data = bind_rows(population.data, row)
}
view(population.data)
#Creates histograms
#################################################################################
#Making Data Summaries
#################################################################################
set.seed(7272)
sample.size = 500
plot.list = list()
summaries.list = list()
i = 1
#Should call calculate distribution
for(i in 1:4)
{
total.distrib = tibble(type = character(), alpha = numeric(), beta = numeric(), mean = numeric(), variance = numeric(),
skewness = numeric(), excess.kurtosis = numeric())
beta.sample = tibble(x = rbeta(n = sample.size, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Stores actual probability density function
population.fig = tibble(x = seq(0, 1, length.out = 1000)) |>
mutate(beta.pdf = dbeta(x, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Creates plots
plot.list[[i]] = ggplot() +
geom_histogram(data = beta.sample, aes(x = x, y = after_stat(density)), fill = "royalblue") +
geom_density(data = beta.sample, aes(x = x, y = after_stat(density), color = "Sample")) +
geom_line(data = population.fig, aes(x = x, y = beta.pdf, color = "Population"))
#Making data summary table
summary = beta.sample %>%
summarize(type = "Sample", mean = mean(x), variance = var(x),
skewness = skewness(x), excess.kurtosis = kurtosis(x),
alpha = alpha.vals[i], beta = beta.vals[i])
total.distrib = bind_rows(total.distrib, summary)
total.distrib = bind_rows(total.distrib, population.data |> slice(i))
summaries.list[[i]] = total.distrib
}
plot.list[[1]]
plot.list[[2]]
plot.list[[3]]
plot.list[[4]]
################################################################################
#Task Four
################################################################################
cum.summ.mean = cummean(pull(population.fig, beta.pdf)) |>
mutate(x = pull(population.fig, x))
library(tidyverse)
library(cumstats)
calculate_distribution <- function(alpha, beta)
{
q1.fig.dat <- tibble(x = seq(-0.25, 1.25, length.out=1000)) |>   # generate a grid of points
mutate(beta.pdf = dbeta(x, alpha, beta),
norm.pdf = dnorm(x, mean = alpha/(alpha+beta),
sd = sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1)))))  # Gaussian distribution with same mean and variance
plot = ggplot(data= q1.fig.dat)+                                              # specify data
geom_line(aes(x=x, y=beta.pdf, color="Beta(2,5)")) +                 # plot beta dist
geom_line(aes(x=x, y=norm.pdf, color="Gaussian(0.2857, 0.0255)")) +  # plot guassian dist
geom_hline(yintercept=0)+                                            # plot x axis
theme_bw()+                                                          # change theme
xlab("x")+                                                           # label x axis
ylab("Density")+                                                     # label y axis
scale_color_manual("", values = c("orange", "grey"))+                 # change colors
theme(legend.position = "bottom")
values = tibble(mean = numeric(1), variance = numeric(1),
skewness = numeric(1), kurtosis = numeric(1)) |>
mutate(mean = alpha/(alpha + beta)) |>
mutate(variance = (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))) |>
mutate(skewness = 2*(beta-alpha)*(alpha+beta+1)^(1/2)/((alpha+beta+2)*(alpha*beta)^(1/2))) |>
mutate(kurtosis = 6*((alpha-beta)^2*(alpha+beta+1)-alpha*beta*(alpha+beta+2))
/(alpha*beta*(alpha+beta+2)*(alpha+beta+3)))
return (list(plot = plot, values = values))
}
alpha.vals = c(2,5,5,.5)
beta.vals = c(5,5,2,.5)
total.data = tibble(mean = numeric(0), variance = numeric(0),
skewness = numeric(0), kurtosis = numeric(0))
all.plots = list()
for(i in 1:4)
{
return.val = calculate_distribution(alpha.vals[i], beta.vals[i])
total.data = bind_rows(total.data, return.val$values)
all.plots[[i]] <- return.val$plot
}
print(all.plots[[1]])
print(all.plots[[2]])
print(all.plots[[3]])
print(all.plots[[4]])
#Step 2:
beta.moment <- function(alpha, beta, k, centered)
{
mean.funct = function(x) x^1*dbeta(x,alpha, beta)
mean.val = integrate(mean.funct,lower = 0,upper = 1)$value
print(mean.val)
if(k == 1)
{
mean.val
}
else if(k == 2)
{
variance.funct = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
variance.val = integrate(variance.funct, 0,1)
variance.val$value
}
else if(k == 3)
{
skewness.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
skewness.val.top = integrate(skewness.funct.top, 0,1)$value
skewness.funct.bott = function(x) (x-mean.val)^(k-1)*dbeta(x,alpha,beta)
skewness.val.bott = integrate(skewness.funct.bott, 0,1)$value
skewness.val = skewness.val.top/(skewness.val.bott^(3/2))
skewness.val
}
else if(k == 4)
{
kurt.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
kurt.val.top = integrate(kurt.funct.top, 0, 1)$value
kurt.funct.bott = function(x) (x-mean.val)^(k-2) *dbeta(x,alpha,beta)
kurt.val.bott = integrate(kurt.funct.bott, 0, 1)$value
kurt.val = kurt.val.top/((kurt.val.bott)^2) -3
kurt.val
}
}
population.data = tibble()
for(i in 1:4)
{
row = tibble() |>
summarize(type = "Population", alpha = alpha.vals[i], beta = beta.vals[i],
mean = beta.moment(alpha.vals[i], beta.vals[i],1,F),
variance = beta.moment(alpha.vals[i], beta.vals[i], 2, T),
skewness = beta.moment(alpha.vals[i], beta.vals[i], 3,T),
excess.kurtosis = beta.moment(alpha.vals[i], beta.vals[i], 4, T))
population.data = bind_rows(population.data, row)
}
view(population.data)
#Creates histograms
#################################################################################
#Making Data Summaries
#################################################################################
set.seed(7272)
sample.size = 500
plot.list = list()
summaries.list = list()
i = 1
#Should call calculate distribution
for(i in 1:4)
{
total.distrib = tibble(type = character(), alpha = numeric(), beta = numeric(), mean = numeric(), variance = numeric(),
skewness = numeric(), excess.kurtosis = numeric())
beta.sample = tibble(x = rbeta(n = sample.size, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Stores actual probability density function
population.fig = tibble(x = seq(0, 1, length.out = 1000)) |>
mutate(beta.pdf = dbeta(x, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Creates plots
plot.list[[i]] = ggplot() +
geom_histogram(data = beta.sample, aes(x = x, y = after_stat(density)), fill = "royalblue") +
geom_density(data = beta.sample, aes(x = x, y = after_stat(density), color = "Sample")) +
geom_line(data = population.fig, aes(x = x, y = beta.pdf, color = "Population"))
#Making data summary table
summary = beta.sample %>%
summarize(type = "Sample", mean = mean(x), variance = var(x),
skewness = skewness(x), excess.kurtosis = kurtosis(x),
alpha = alpha.vals[i], beta = beta.vals[i])
total.distrib = bind_rows(total.distrib, summary)
total.distrib = bind_rows(total.distrib, population.data |> slice(i))
summaries.list[[i]] = total.distrib
}
plot.list[[1]]
plot.list[[2]]
plot.list[[3]]
plot.list[[4]]
################################################################################
#Task Four
################################################################################
cum.summ.mean = tibble(dat = cummean(pull(population.fig, beta.pdf))) |>
mutate(x = pull(population.fig, x))
mean.plot = ggplot(data = cum.summ.mean) +
geom_line(aes(x = x, y = cum.summ.mean), color = "green")
mean.plot
library(tidyverse)
library(cumstats)
calculate_distribution <- function(alpha, beta)
{
q1.fig.dat <- tibble(x = seq(-0.25, 1.25, length.out=1000)) |>   # generate a grid of points
mutate(beta.pdf = dbeta(x, alpha, beta),
norm.pdf = dnorm(x, mean = alpha/(alpha+beta),
sd = sqrt((alpha*beta)/((alpha+beta)^2*(alpha+beta+1)))))  # Gaussian distribution with same mean and variance
plot = ggplot(data= q1.fig.dat)+                                              # specify data
geom_line(aes(x=x, y=beta.pdf, color="Beta(2,5)")) +                 # plot beta dist
geom_line(aes(x=x, y=norm.pdf, color="Gaussian(0.2857, 0.0255)")) +  # plot guassian dist
geom_hline(yintercept=0)+                                            # plot x axis
theme_bw()+                                                          # change theme
xlab("x")+                                                           # label x axis
ylab("Density")+                                                     # label y axis
scale_color_manual("", values = c("orange", "grey"))+                 # change colors
theme(legend.position = "bottom")
values = tibble(mean = numeric(1), variance = numeric(1),
skewness = numeric(1), kurtosis = numeric(1)) |>
mutate(mean = alpha/(alpha + beta)) |>
mutate(variance = (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))) |>
mutate(skewness = 2*(beta-alpha)*(alpha+beta+1)^(1/2)/((alpha+beta+2)*(alpha*beta)^(1/2))) |>
mutate(kurtosis = 6*((alpha-beta)^2*(alpha+beta+1)-alpha*beta*(alpha+beta+2))
/(alpha*beta*(alpha+beta+2)*(alpha+beta+3)))
return (list(plot = plot, values = values))
}
alpha.vals = c(2,5,5,.5)
beta.vals = c(5,5,2,.5)
total.data = tibble(mean = numeric(0), variance = numeric(0),
skewness = numeric(0), kurtosis = numeric(0))
all.plots = list()
for(i in 1:4)
{
return.val = calculate_distribution(alpha.vals[i], beta.vals[i])
total.data = bind_rows(total.data, return.val$values)
all.plots[[i]] <- return.val$plot
}
print(all.plots[[1]])
print(all.plots[[2]])
print(all.plots[[3]])
print(all.plots[[4]])
#Step 2:
beta.moment <- function(alpha, beta, k, centered)
{
mean.funct = function(x) x^1*dbeta(x,alpha, beta)
mean.val = integrate(mean.funct,lower = 0,upper = 1)$value
print(mean.val)
if(k == 1)
{
mean.val
}
else if(k == 2)
{
variance.funct = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
variance.val = integrate(variance.funct, 0,1)
variance.val$value
}
else if(k == 3)
{
skewness.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
skewness.val.top = integrate(skewness.funct.top, 0,1)$value
skewness.funct.bott = function(x) (x-mean.val)^(k-1)*dbeta(x,alpha,beta)
skewness.val.bott = integrate(skewness.funct.bott, 0,1)$value
skewness.val = skewness.val.top/(skewness.val.bott^(3/2))
skewness.val
}
else if(k == 4)
{
kurt.funct.top = function(x) (x-mean.val)^k*dbeta(x,alpha,beta)
kurt.val.top = integrate(kurt.funct.top, 0, 1)$value
kurt.funct.bott = function(x) (x-mean.val)^(k-2) *dbeta(x,alpha,beta)
kurt.val.bott = integrate(kurt.funct.bott, 0, 1)$value
kurt.val = kurt.val.top/((kurt.val.bott)^2) -3
kurt.val
}
}
population.data = tibble()
for(i in 1:4)
{
row = tibble() |>
summarize(type = "Population", alpha = alpha.vals[i], beta = beta.vals[i],
mean = beta.moment(alpha.vals[i], beta.vals[i],1,F),
variance = beta.moment(alpha.vals[i], beta.vals[i], 2, T),
skewness = beta.moment(alpha.vals[i], beta.vals[i], 3,T),
excess.kurtosis = beta.moment(alpha.vals[i], beta.vals[i], 4, T))
population.data = bind_rows(population.data, row)
}
view(population.data)
#Creates histograms
#################################################################################
#Making Data Summaries
#################################################################################
set.seed(7272)
sample.size = 500
plot.list = list()
summaries.list = list()
i = 1
#Should call calculate distribution
for(i in 1:4)
{
total.distrib = tibble(type = character(), alpha = numeric(), beta = numeric(), mean = numeric(), variance = numeric(),
skewness = numeric(), excess.kurtosis = numeric())
beta.sample = tibble(x = rbeta(n = sample.size, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Stores actual probability density function
population.fig = tibble(x = seq(0, 1, length.out = 1000)) |>
mutate(beta.pdf = dbeta(x, shape1 = alpha.vals[i], shape2 = beta.vals[i]))
#Creates plots
plot.list[[i]] = ggplot() +
geom_histogram(data = beta.sample, aes(x = x, y = after_stat(density)), fill = "royalblue") +
geom_density(data = beta.sample, aes(x = x, y = after_stat(density), color = "Sample")) +
geom_line(data = population.fig, aes(x = x, y = beta.pdf, color = "Population"))
#Making data summary table
summary = beta.sample %>%
summarize(type = "Sample", mean = mean(x), variance = var(x),
skewness = skewness(x), excess.kurtosis = kurtosis(x),
alpha = alpha.vals[i], beta = beta.vals[i])
total.distrib = bind_rows(total.distrib, summary)
total.distrib = bind_rows(total.distrib, population.data |> slice(i))
summaries.list[[i]] = total.distrib
}
plot.list[[1]]
plot.list[[2]]
plot.list[[3]]
plot.list[[4]]
################################################################################
#Task Four
################################################################################
cum.summ.mean = tibble(dat = cummean(pull(population.fig, beta.pdf))) |>
mutate(x = pull(population.fig, x))
mean.plot = ggplot(data = cum.summ.mean) +
geom_line(aes(x = x, y = dat), color = "green")
mean.plot
